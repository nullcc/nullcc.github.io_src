---
title: 设计模式(1)——单例模式
date: 2017-12-05
tags: [设计模式]
categories: 设计模式
---

本文介绍单例模式的概念和应用。

<!--more-->

## 基本思想和原则

单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式有以下三个要素：

1. 保证类实例的唯一性。
2. 提供一个获取类唯一实例的全局访问点。
3. 类必须自行创建这个唯一的实例，不能由用户手动创建。

## 动机

在一些情况下我们希望某个类在系统中有且仅有一个实例，常见的例子有全局id生成器、任务管理器、全局计时器、配置对象等。如果这些类的对象有多个，可能造成数据不一致的情况，因此需要一种通用的模式来保证这些类在系统中有且仅有一个实例。

## 实现

下面用Python代码来实现一个单例类，其中用到了`__new__`机制：

```Python
class Singleton():
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance

obj1 = Singleton()
obj2 = Singleton()

print(id(obj1))  # 4333257784
print(id(obj2))  # 4333257784
```

Python的`__new__`方法在`__init__`之前调用，用于真正地创建一个实例。在上面的`Singleton`类中，有一个类变量`_instance`，在创建实例时会判断`_instance`是否已经存在，如果不存在就创建它然后返回，否则直接返回`_instance`。可以发现`obj1`和`obj2`的id一定是相同的，也就是说`obj1`和`obj2`完全就是同一个对象。这种做法就像在创建类的实例时候有一道屏障。

还有一种实现是使用装饰器：

```Python
from functools import wraps

def singleton(cls):
    instances = {}
    @wraps(cls)
    def getInstace(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return getInstace

@singleton
class MyClass():
    pass

obj1 = MyClass()
obj2 = MyClass()

print(id(obj1))  # 4341646336
print(id(obj2))  # 4341646336
```

---
title: (译)深入理解Node.js的事件循环、定时器和process.nextTick()
date: 2018-10-11
tags: [node]
categories: 文档翻译
---

本文翻译自[The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)。

<!--more-->

## 事件循环是什么？

事件循环通过尽可能地将操作交给内核处理来允许Node.js执行非阻塞I/O操作 —— 尽管JavaScript是单线程的。

由于大多数现在内核都是多线程的，它们可以在后台执行多个操作。当其中一个操作执行完毕时，内核会通知Node.js，以便可以将相应的回调函数加入到轮询队列中等待最终被执行。稍后我们将在本主题中详细解释这一细节。


## 事件循环详解

当Node.js将在启动时初始化事件循环，处理输入脚本（或者进入REPL，不过这不在本文讨论范围内），在脚本中可能会异步调用API，调度定时器或者调用process.nextTick()，然后开始处理事件循环。

下图展示了事件循环的操作顺序的简化概述。

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

注意：每个方框都被称为事件循环中的一个“阶段”。

每个阶段都拥有一个FIFO队列来存放将要被执行的回调函数。虽然每个阶段都有自己独特的地方，但一般情况下，当事件循环进入一个给定的阶段时，它将执行该阶段的任何特定操作，然后从该阶段维护的回调函数FIFO队列中取回调函数来执行，直到队列为空或者达到回调函数执行的最大次数为止。当队列为空或者达到了回调函数的最大执行次数，事件循环将进入下一个阶段，一直这样重复下去。

由于这些操作中的任何一个都有可能再调度更多的操作，且新事件的处理在轮询阶段需要在内核中排队，轮询事件可以在处理轮询事件时排队。因此，长时间运行的回调可以使轮询阶段运行得比计时器的阈值长得多。关于这部分内容可以查阅[定时器](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#timers)和[轮询](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#poll)章节了解更多细节。

注意：事件循环在Windows和Unix/Linux实现上有一个微小的差异，但这在这里并不重要。本文将讲解上面展示的最重要的七到八个步骤。


## 阶段概述

- 定时器阶段： 该阶段将执行所有被setTimeout()和setInterval()调度的回调。
- 未解决的回调阶段：该阶段将执行那些被延迟到下一个事件循环迭代的回调。
- 空闲和准备阶段：该阶段只在内部被使用到
- 轮询阶段： 检索新的I/O事件；执行和I/O相关的回调（即除了关闭回调、被定时器调度的回调和被setImmediate()调度的回调以外的几乎所有回调）；Node.js将在适当的时候阻塞在此。
- 检查阶段：该阶段将执行被setImmediate()调度的回调。
- 关闭回调阶段：该阶段将执行一些关闭回调，比如socket.on('close', ...)中指定的回调。

Between each run of the event loop, Node.js checks if it is waiting for any asynchronous I/O or timers and shuts down cleanly if there are not any.

在事件循环的每次运行的之间，Node.js会检查它是否在等待任何异步I/O或者定时器，如果没有，则关闭。

## 事件循环中每个阶段的细节

// todo
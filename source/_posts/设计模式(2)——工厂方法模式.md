---
title: 设计模式(2)——工厂方法模式
date: 2017-12-05
tags: [设计模式]
categories: 设计模式
---

本文介绍工厂方法模式的概念和应用。

<!--more-->

## 基本思想和原则

客户代码不要依赖具体类，而是要依赖抽象。定义一个用来创建对象的通用接口，让子类实现这个接口，并将具体对象的创建延迟到子类中进行。

## 动机

假设某个抽象类有三个子类A、B和C，当需要客户代码需要使用这个抽象类体系时，最简单的方式是根据需要的功能选择相应的子类来创建对象。但是这么做有一个问题，当子类很多时或子类的初始化比较复杂时，客户代码会严重地依赖子类的具体实现。比如客户代码可能是这样子的：

```Python

class Hamburger():
    pass

class BeefHamburger(Hamburger):
    pass

class PorkHamburger(Hamburger):
    pass

class ChickenHamburger(Hamburger):
    pass

def make_hamburger(hamburger_type):
    if hamburger_type == 'beef':
        return BeefHamburger()
    elif hamburger_type == 'pork':
        return PorkHamburger()
    elif hamburger_type == 'chicken':
        return ChickenHamburger()
```

在客户代码`make_hamburger`函数中，必须根据入参`tyhamburger_typepe`来选择要创建哪个具体汉堡类的实例。如果后面想要加一个鱼肉汉堡类，就必须修改`make_hamburger`函数加一个判断分支，这意味着要修改客户代码，如果项目中有多个地方都使用这种方式创建汉堡对象，这些地方要一个个去修改，非常麻烦，很容易漏掉某处。这种实现方式的问题在于客户代码过分依赖具体的实现类，具体实现类有改动时，客户代码也要跟着改。

为了解决客户代码过分依赖具体类的问题，可以定义一个工厂类，由这个工厂类来决定要创建哪个具体类的实例，各个子类还是负责自己的事情就好。当要加入一个新的子类时，只需要修改工厂类，客户代码不用做任何修改。

## 实现

还是刚才制作汉堡的例子，这次定义一个工厂类`HamburgerFactory`，并且新增了一个鱼肉汉堡类：

```Python
class Hamburger():
    pass

class BeefHamburger(Hamburger):
    pass

class PorkHamburger(Hamburger):
    pass

class ChickenHamburger(Hamburger):
    pass

class FishHamburger(Hamburger):
    pass

class HamburgerFactory(hamburger_type):
    def make_hamburger(hamburger_type):
        if hamburger_type == 'beef':
            return BeefHamburger()
        elif hamburger_type == 'pork':
            return PorkHamburger()
        elif hamburger_type == 'chicken':
            return ChickenHamburger()
        elif hamburger_type == 'fish':
            return FishHamburger()

def make_hamburger(hamburger_type):
    return HamburgerFactory.make_hamburger(hamburger_type)
```

在上面的代码中，当客户代码想创建某个类型的汉堡时，只需要调用`HamburgerFactory.make_hamburger`方法，将汉堡类型作为参数传入即可。之后再增加新的汉堡类型时，也只需要修改`HamburgerFactory.make_hamburger`的实现就好。